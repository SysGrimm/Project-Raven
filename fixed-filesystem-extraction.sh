#!/bin/bash

# FIXED copy_and_customize_filesystems function 
# This replaces the broken e2cp -r logic in build-soulbox-containerized.sh

# Function to extract directory contents recursively using correct e2tools syntax
extract_directory_contents() {
    local source_img="$1"
    local source_dir="$2"
    local target_dir="$3"
    local max_files="${4:-1000}"
    
    # Create target directory
    mkdir -p "$target_dir"
    
    # Get directory listing
    local items
    items=$(e2ls "$source_img:$source_dir" 2>/dev/null || echo "")
    
    if [[ -z "$items" ]]; then
        return 1
    fi
    
    local files_copied=0
    local total_processed=0
    
    # Process each item
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        [[ "$item" =~ ^\.\.?/?$ ]] && continue  # Skip . and ..
        
        # Limit extraction to prevent runaway copying
        if [[ $total_processed -ge $max_files ]]; then
            echo "    Reached file limit ($max_files) for $source_dir"
            break
        fi
        
        local source_item="$source_dir/$item"
        local target_item="$target_dir/$item"
        
        # Check if it's a directory (ends with /)
        if [[ "$item" =~ /$ ]]; then
            # Directory - recurse into it (limited depth)
            local clean_name="${item%/}"
            local sub_source="$source_dir/$clean_name"
            local sub_target="$target_dir/$clean_name"
            
            # Only recurse 3 levels deep to avoid excessive copying
            if [[ $(echo "$source_dir" | tr -cd '/' | wc -c) -lt 3 ]]; then
                extract_directory_contents "$source_img" "$sub_source" "$sub_target" 100
            fi
        else\n            # File - copy it\n            if e2cp "$source_img:$source_item" "$target_item" 2>/dev/null; then\n                files_copied=$((files_copied + 1))\n            fi\n        fi\n        \n        total_processed=$((total_processed + 1))\n    done <<< "$items"\n    \n    echo "    $source_dir: $files_copied files extracted"\n    return 0\n}\n\n# CORRECTED copy_and_customize_filesystems function\ncopy_and_customize_filesystems() {\n    # Temporarily disable set -e for better error handling\n    set +e\n    \n    local temp_dir="$1"\n    local pi_boot="$WORK_DIR/filesystems/pi-boot.fat"\n    local pi_root="$WORK_DIR/filesystems/pi-root.ext4"\n    local assets_dir="$WORK_DIR/soulbox-assets"\n    \n    log_info "=== Starting filesystem copying phase ==="\n    log_info "Temp dir: $temp_dir"\n    log_info "Pi boot: $pi_boot"\n    log_info "Pi root: $pi_root"\n    log_info "Assets: $assets_dir"\n    \n    log_info "Copying Pi OS content and adding SoulBox customizations..."\n    \n    # Verify input files exist\n    log_info "Checking input files..."\n    if [[ ! -f "$pi_boot" ]]; then\n        log_error "Boot partition file missing: $pi_boot"\n        set -e\n        return 1\n    fi\n    log_success "Boot partition file found: $(ls -lh "$pi_boot" | awk '{print $5}')"\n    \n    if [[ ! -f "$pi_root" ]]; then\n        log_error "Root partition file missing: $pi_root"\n        set -e\n        return 1\n    fi\n    log_success "Root partition file found: $(ls -lh "$pi_root" | awk '{print $5}')"\n    \n    if [[ ! -d "$assets_dir" ]]; then\n        log_error "Assets directory missing: $assets_dir"\n        set -e\n        return 1\n    fi\n    log_success "Assets directory found"\n    \n    # Copy Pi OS boot content (this works fine)\n    log_info "Processing boot partition..."\n    mkdir -p "$temp_dir/boot-content"\n    \n    # Extract boot content using mtools\n    log_info "Extracting boot partition content..."\n    if mcopy -s -i "$pi_boot" :: "$temp_dir/boot-content/" 2>&1; then\n        log_success "Boot partition extracted successfully"\n        log_info "Boot files found: $(ls -la "$temp_dir/boot-content/" | wc -l) items"\n    else\n        log_warning "Boot partition extraction failed, creating minimal setup"\n        # Create minimal boot files\n        touch "$temp_dir/boot-content/config.txt"\n        touch "$temp_dir/boot-content/cmdline.txt"\n        echo "# Minimal boot configuration" > "$temp_dir/boot-content/config.txt"\n        echo "console=serial0,115200 console=tty1 root=PARTUUID=ROOT_PARTUUID rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait" > "$temp_dir/boot-content/cmdline.txt"\n    fi\n    \n    # Add SoulBox boot customizations\n    if [[ -f "$assets_dir/boot/soulbox-config.txt" ]]; then\n        log_info "Adding SoulBox boot configuration..."\n        cat "$assets_dir/boot/soulbox-config.txt" >> "$temp_dir/boot-content/config.txt"\n        log_success "Boot configuration added"\n    else\n        log_warning "SoulBox boot config not found: $assets_dir/boot/soulbox-config.txt"\n    fi\n    \n    # Ensure essential boot files are present\n    log_info "Ensuring essential Pi boot files are present..."\n    local essential_files=("start4.elf" "fixup4.dat" "bcm2712-rpi-5-b.dtb" "kernel8.img" "config.txt" "cmdline.txt")\n    for essential_file in "${essential_files[@]}"; do\n        if [[ ! -f "$temp_dir/boot-content/$essential_file" ]]; then\n            log_warning "Essential boot file missing: $essential_file"\n            # For now, create placeholder - ideally should extract from Pi OS image\n            if [[ "$essential_file" == "config.txt" ]]; then\n                echo "# Raspberry Pi Configuration" > "$temp_dir/boot-content/config.txt"\n            elif [[ "$essential_file" == "cmdline.txt" ]]; then\n                echo "console=serial0,115200 console=tty1 root=PARTUUID=ROOT_PARTUUID rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait" > "$temp_dir/boot-content/cmdline.txt"\n            fi\n        fi\n    done\n    \n    # Copy back to new boot filesystem using proper mtools commands\n    log_info "Populating new boot filesystem..."\n    local boot_copy_count=0\n    local boot_copy_failures=0\n    \n    # First, ensure the FAT32 filesystem is accessible\n    if ! mdir -i "$temp_dir/boot-new.fat" :: >/dev/null 2>&1; then\n        log_error "Cannot access newly created boot filesystem"\n        return 1\n    fi\n    \n    # Copy files one by one with better error handling\n    for file in "$temp_dir/boot-content"/*; do\n        if [[ -f "$file" ]]; then\n            filename=$(basename "$file")\n            log_info "Copying boot file: $filename"\n            if mcopy -i "$temp_dir/boot-new.fat" "$file" "::$filename" 2>/dev/null; then\n                boot_copy_count=$((boot_copy_count + 1))\n            else\n                log_warning "Failed to copy $filename to boot partition"\n                boot_copy_failures=$((boot_copy_failures + 1))\n            fi\n        fi\n    done\n    \n    log_success "Boot filesystem populated with $boot_copy_count files ($boot_copy_failures failed)"\n    \n    # Verify boot filesystem has files\n    log_info "Verifying boot filesystem contents..."\n    if mdir -i "$temp_dir/boot-new.fat" :: 2>/dev/null | grep -q .; then\n        local file_count=$(mdir -i "$temp_dir/boot-new.fat" :: 2>/dev/null | grep -c '^[^d]' || echo "0")\n        log_success "Boot filesystem verification passed: $file_count files found"\n    else\n        log_error "Boot filesystem appears to be empty!"\n        return 1\n    fi\n    \n    # Process root filesystem - THIS IS THE FIXED PART\n    log_info "Processing root partition..."\n    mkdir -p "$temp_dir/root-content"\n    \n    # Create essential Pi OS directory structure\n    log_info "Creating directory structure..."\n    local dirs=("bin" "boot/firmware" "dev" "etc/systemd/system" "etc/apt" "etc/ssh" "home" "lib" "media" "mnt" "opt" "proc" "root" "run" "sbin" "srv" "sys" "tmp" "usr/bin" "usr/lib" "usr/local" "usr/share" "var/log" "var/tmp" "var/cache")\n    for dir in "${dirs[@]}"; do\n        mkdir -p "$temp_dir/root-content/$dir"\n    done\n    log_success "Directory structure created"\n    \n    # Copy SoulBox root customizations\n    if [[ -d "$assets_dir/root" ]]; then\n        log_info "Copying SoulBox assets..."\n        if cp -r "$assets_dir/root"/* "$temp_dir/root-content/" 2>&1; then\n            log_success "SoulBox assets copied successfully"\n        else\n            log_warning "Some SoulBox assets may not have copied properly"\n        fi\n    else\n        log_warning "SoulBox assets directory not found: $assets_dir/root"\n    fi\n    \n    # FIXED: Use robust Pi OS extraction with correct e2tools syntax\n    log_info "Performing comprehensive Pi OS root filesystem extraction..."\n    \n    # Create temporary extraction area\n    local pi_extract_dir="$temp_dir/pi-root-extract"\n    mkdir -p "$pi_extract_dir"\n    \n    # Critical system directories with size limits for container friendliness\n    local critical_dirs=(\n        "/bin:/bin:500"                    # Essential binaries (limit 500 files)\n        "/sbin:/sbin:300"                  # System binaries (limit 300 files)\n        "/lib/aarch64-linux-gnu:/lib/aarch64-linux-gnu:2000"  # Libraries (limit 2000 files)\n        "/lib/systemd:/lib/systemd:1000"   # Systemd (limit 1000 files)\n        "/lib/modules:/lib/modules:5000"   # Kernel modules (limit 5000 files - critical)\n        "/lib/firmware:/lib/firmware:1000" # Firmware (limit 1000 files)\n        "/etc:/etc:2000"                   # System config (limit 2000 files)\n        "/usr/bin:/usr/bin:1000"           # User binaries (limit 1000 files)\n        "/usr/sbin:/usr/sbin:500"          # User system binaries (limit 500 files)\n    )\n    \n    local total_extracted=0\n    local total_failed=0\n    \n    for dir_spec in "${critical_dirs[@]}"; do\n        IFS=':' read -r source_dir target_rel_dir max_files <<< "$dir_spec"\n        log_info "Extracting essential system directory: $source_dir (max $max_files files)"\n        \n        local target_dir="$pi_extract_dir$target_rel_dir"\n        \n        # Use our robust extraction function\n        if extract_directory_contents "$pi_root" "$source_dir" "$target_dir" "$max_files"; then\n            total_extracted=$((total_extracted + 1))\n            log_success "Extracted system directory: $source_dir"\n        else\n            log_warning "Failed to extract system directory: $source_dir"\n            total_failed=$((total_failed + 1))\n            \n            # Create minimal directory structure\n            mkdir -p "$target_dir"\n            \n            # For critical directories, try individual file extraction\n            if [[ "$source_dir" == "/bin" ]]; then\n                log_info "Attempting to extract critical /bin files individually..."\n                local bin_files=("bash" "sh" "ls" "cp" "mv" "rm" "mount" "umount" "cat" "grep" "sed")\n                for bin_file in "${bin_files[@]}"; do\n                    if e2cp "$pi_root:/bin/$bin_file" "$pi_extract_dir/bin/$bin_file" 2>/dev/null; then\n                        log_info "✓ /bin/$bin_file"\n                    else\n                        log_warning "✗ /bin/$bin_file"\n                    fi\n                done\n            elif [[ "$source_dir" == "/sbin" ]]; then\n                log_info "Attempting to extract critical /sbin files individually..."\n                local sbin_files=("init" "fsck" "blkid" "mke2fs")\n                for sbin_file in "${sbin_files[@]}"; do\n                    if e2cp "$pi_root:/sbin/$sbin_file" "$pi_extract_dir/sbin/$sbin_file" 2>/dev/null; then\n                        log_info "✓ /sbin/$sbin_file"\n                    else\n                        log_warning "✗ /sbin/$sbin_file"\n                    fi\n                done\n            elif [[ "$source_dir" == "/lib/modules" ]]; then\n                log_info "Attempting kernel module extraction using kernel detection..."\n                mkdir -p "$pi_extract_dir/lib/modules"\n                \n                # Find kernel versions\n                local kernel_versions\n                kernel_versions=$(e2ls "$pi_root:/lib/modules" 2>/dev/null | grep -E '^[0-9]+\\.[0-9]+\\.[0-9]+' | head -3)\n                \n                if [[ -n "$kernel_versions" ]]; then\n                    while IFS= read -r kernel_ver; do\n                        [[ -z "$kernel_ver" ]] && continue\n                        \n                        # Remove trailing / if present\n                        kernel_ver="${kernel_ver%/}"\n                        \n                        log_info "Extracting kernel modules for: $kernel_ver"\n                        if extract_directory_contents "$pi_root" "/lib/modules/$kernel_ver" "$pi_extract_dir/lib/modules/$kernel_ver" 1000; then\n                            log_success "✓ /lib/modules/$kernel_ver"\n                        else\n                            log_warning "✗ /lib/modules/$kernel_ver"\n                        fi\n                    done <<< "$kernel_versions"\n                else\n                    log_error "Could not determine kernel version for module extraction"\n                fi\n            fi\n        fi\n    done\n    \n    # Extract critical individual files\n    log_info "Extracting critical system files..."\n    local critical_files=(\n        "/lib/ld-linux-aarch64.so.1:/lib/ld-linux-aarch64.so.1"\n        "/etc/passwd:/etc/passwd"\n        "/etc/group:/etc/group"\n        "/etc/shadow:/etc/shadow"\n        "/etc/fstab:/etc/fstab"\n        "/etc/hostname:/etc/hostname"\n        "/etc/hosts:/etc/hosts"\n    )\n    \n    for file_spec in "${critical_files[@]}"; do\n        IFS=':' read -r source_file target_file <<< "$file_spec"\n        local full_target="$pi_extract_dir$target_file"\n        local target_dir=$(dirname "$full_target")\n        \n        mkdir -p "$target_dir"\n        if e2cp "$pi_root:$source_file" "$full_target" 2>/dev/null; then\n            log_info "✓ $source_file"\n        else\n            log_warning "✗ $source_file"\n        fi\n    done\n    \n    log_info "Pi OS extraction summary: $total_extracted directories succeeded, $total_failed failed"\n    \n    # Copy extracted Pi OS content to our root-content directory\n    log_info "Merging extracted Pi OS content with SoulBox customizations..."\n    if [[ -d "$pi_extract_dir" ]]; then\n        # Copy everything from the extracted Pi OS, but don't overwrite SoulBox files\n        cp -r "$pi_extract_dir"/* "$temp_dir/root-content/" 2>/dev/null || true\n        log_success "Pi OS content merged with SoulBox customizations"\n        \n        # Clean up extraction directory\n        rm -rf "$pi_extract_dir"\n    fi\n    \n    # Create essential system files (fallback if extraction failed)\n    log_info "Ensuring essential system files exist..."\n    if [[ ! -f "$temp_dir/root-content/etc/passwd" ]]; then\n        cat > "$temp_dir/root-content/etc/passwd" << 'EOF'\nroot:x:0:0:root:/root:/bin/bash\npi:x:1000:1000:Raspberry Pi User,,,:/home/pi:/bin/bash\nsoulbox:x:1001:1001:SoulBox User,,,:/home/soulbox:/bin/bash\nEOF\n    fi\n    \n    if [[ ! -f "$temp_dir/root-content/etc/group" ]]; then\n        cat > "$temp_dir/root-content/etc/group" << 'EOF'\nroot:x:0:\npi:x:1000:\nsoulbox:x:1001:\nvideo:x:44:soulbox\naudio:x:29:soulbox\nEOF\n    fi\n    \n    if [[ ! -f "$temp_dir/root-content/etc/shadow" ]]; then\n        cat > "$temp_dir/root-content/etc/shadow" << 'EOF'\nroot:*:19000:0:99999:7:::\npi:*:19000:0:99999:7:::\nsoulbox:*:19000:0:99999:7:::\nEOF\n    fi\n    \n    if [[ ! -f "$temp_dir/root-content/etc/fstab" ]]; then\n        cat > "$temp_dir/root-content/etc/fstab" << 'EOF'\nproc            /proc           proc    defaults          0       0\nLABEL=SOULBOX  /boot/firmware  vfat    defaults          0       2\nLABEL=soulbox-root /               ext4    defaults,noatime  0       1\nEOF\n    fi\n    \n    # Ensure critical shell binaries exist\n    if [[ ! -f "$temp_dir/root-content/bin/sh" ]]; then\n        log_info "Creating /bin/sh fallback (copying bash)"\n        if [[ -f "$temp_dir/root-content/bin/bash" ]]; then\n            cp "$temp_dir/root-content/bin/bash" "$temp_dir/root-content/bin/sh"\n        else\n            log_warning "No bash available for /bin/sh fallback - creating minimal script"\n            mkdir -p "$temp_dir/root-content/bin"\n            cat > "$temp_dir/root-content/bin/sh" << 'EOF'\n#!/bin/dash\n# Minimal sh fallback for SoulBox - will be replaced during first boot\nexec "$@"\nEOF\n            chmod +x "$temp_dir/root-content/bin/sh"\n        fi\n    fi\n    \n    # Create home directories\n    mkdir -p "$temp_dir/root-content/home/pi"\n    mkdir -p "$temp_dir/root-content/home/soulbox"\n    mkdir -p "$temp_dir/root-content/root"\n    \n    log_success "Essential system files verified"\n    \n    # Verify filesystem before populating\n    if [[ ! -f "$temp_dir/root-new.ext4" ]]; then\n        log_error "Root filesystem image missing: $temp_dir/root-new.ext4"\n        return 1\n    fi\n    \n    # Test e2tools functionality\n    log_info "Testing e2tools functionality..."\n    if e2ls "$temp_dir/root-new.ext4:" >/dev/null 2>&1; then\n        log_success "e2tools can access the filesystem"\n    else\n        log_error "e2tools cannot access the filesystem - this will cause failure"\n        return 1\n    fi\n    \n    # Populate the ext4 filesystem using e2cp\n    log_info "Populating root filesystem with e2tools..."\n    \n    # Create directories first - using a different approach due to e2tools limitations\n    local dir_count=0\n    local file_count=0\n    local failed_ops=0\n    \n    log_info "Creating essential directories in ext4 filesystem..."\n    # Create critical directories individually without -p flag (e2mkdir doesn't support -p reliably)\n    local essential_dirs=("bin" "boot" "dev" "etc" "home" "lib" "media" "mnt" "opt" "proc" "root" "run" "sbin" "srv" "sys" "tmp" "usr" "var")\n    for dir in "${essential_dirs[@]}"; do\n        if e2mkdir "$temp_dir/root-new.ext4:/$dir" 2>/dev/null; then\n            dir_count=$((dir_count + 1))\n        else\n            failed_ops=$((failed_ops + 1))\n        fi\n    done\n    \n    # Create nested directories one level at a time\n    local nested_dirs=("boot/firmware" "etc/systemd" "etc/apt" "etc/ssh" "home/soulbox" "home/pi" "opt/soulbox" "usr/bin" "usr/lib" "usr/local" "usr/share" "var/log" "var/tmp" "var/cache")\n    for dir in "${nested_dirs[@]}"; do\n        if e2mkdir "$temp_dir/root-new.ext4:/$dir" 2>/dev/null; then\n            dir_count=$((dir_count + 1))\n        else\n            failed_ops=$((failed_ops + 1))\n        fi\n    done\n    \n    log_success "Created $dir_count directories (failed: $failed_ops)"\n    \n    # Copy files to ext4 filesystem\n    log_info "Copying files to ext4 filesystem..."\n    find "$temp_dir/root-content" -type f | while read -r file; do\n        local rel_path="${file#$temp_dir/root-content}"\n        local target_path="$temp_dir/root-new.ext4:$rel_path"\n        \n        if e2cp "$file" "$target_path" 2>/dev/null; then\n            file_count=$((file_count + 1))\n        else\n            failed_ops=$((failed_ops + 1))\n        fi\n    done\n    \n    log_success "Copied $file_count files (failed: $failed_ops)"\n    \n    # Handle symbolic links (e2tools doesn't support symlinks well)\n    log_info "Processing symbolic links..."\n    local symlink_count=0\n    find "$temp_dir/root-content" -type l | while read -r link; do\n        local rel_path="${link#$temp_dir/root-content}"\n        local link_target=$(readlink "$link")\n        \n        # Store symlink info for later restoration\n        echo "$rel_path -> $link_target" >> "$temp_dir/root-content/opt/soulbox/restore-symlinks.txt"\n        log_info "Creating symlink workaround for: $rel_path -> $link_target"\n        symlink_count=$((symlink_count + 1))\n    done\n    \n    if [[ $symlink_count -gt 0 ]]; then\n        log_info "Creating symlink restoration script for $symlink_count links"\n        cat > "$temp_dir/root-content/opt/soulbox/restore-symlinks.sh" << 'EOF'\n#!/bin/bash\n# Restore symbolic links that couldn't be created during image build\nif [[ -f /opt/soulbox/restore-symlinks.txt ]]; then\n    while IFS=' -> ' read -r link_path target_path; do\n        [[ -z "$link_path" || -z "$target_path" ]] && continue\n        rm -f "$link_path" 2>/dev/null\n        ln -sf "$target_path" "$link_path" 2>/dev/null\n    done < /opt/soulbox/restore-symlinks.txt\n    rm -f /opt/soulbox/restore-symlinks.txt\nfi\nEOF\n        chmod +x "$temp_dir/root-content/opt/soulbox/restore-symlinks.sh"\n        \n        # Copy the symlink restoration files\n        e2cp "$temp_dir/root-content/opt/soulbox/restore-symlinks.txt" "$temp_dir/root-new.ext4:/opt/soulbox/restore-symlinks.txt" 2>/dev/null || true\n        e2cp "$temp_dir/root-content/opt/soulbox/restore-symlinks.sh" "$temp_dir/root-new.ext4:/opt/soulbox/restore-symlinks.sh" 2>/dev/null || true\n    fi\n    \n    # Verify populated filesystem\n    log_info "Verifying populated filesystem..."\n    local root_items=$(e2ls "$temp_dir/root-new.ext4:/" 2>/dev/null | wc -l || echo "0")\n    if [[ $root_items -gt 0 ]]; then\n        log_success "Filesystem populated successfully - $root_items items in root"\n    else\n        log_error "Filesystem appears to be empty after population!"\n        return 1\n    fi\n    \n    log_success "Filesystem customization complete"\n    \n    # Re-enable strict error handling\n    set -e\n    return 0\n}\n\necho "This file contains the corrected copy_and_customize_filesystems function"\necho "Replace the existing function in build-soulbox-containerized.sh with this version"\necho "Key fixes:"\necho "1. Removed non-existent 'e2cp -r' usage"\necho "2. Added proper recursive extraction using e2ls + e2cp"\necho "3. Added file limits to prevent excessive copying in containers"\necho "4. Added robust fallback methods for critical directories"\necho "5. Proper error handling and logging throughout"
